<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>data structure</title>
    <link rel="icon" href="tap logo.png">
</head>
<body bgcolor="#ECF8F9">
<img src="7dqv1v4a.png" height="50px" width="120px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;<a href="index.html"><font size="5px" align="center">Home</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="course.html"><font size="5px" align="center">Course</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="student_review.html">
<font size="5px" align="center">Student Reviews</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="blogs.html"><font size="5px" align="center">Blogs</font></a>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="placement.html">
<font size="5px" align="center">Placements</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="contact us.html"><font size="5px" align="center">Contact Us</font></a>   
<hr color="#E4F1FF"><br>
<center><h1>What is Data Structure and Algorithm?</h1></center>
<font size="4px" face="cursive">
You may already know that computers are used to store and modify massive amounts of data. Data structures are used to efficiently <br>
and conveniently arrange and store data. <br><br>
Organizing and storing data in a computer so that it can be accessed and used effectively is known as a data structure.In addition <br>
to defining the relationships between data pieces, it offers a means of representing and storing data. Common data structures include <br>
trees, stacks, queues, linked lists, arrays, and stacks. <br><br>
Now,an algorithm is a set of guidelines or procedures used to complete a task or solve a problem.To get a certain outcome,algorithms <br> 
are used to alter data that is stored in data structures. Data in an array or linked list can be sorted using a sorting algorithm, <br>
for instance. <br><br>
Data structures and algorithms are closely associated in computer science because an algorithm’s effectiveness frequently depends <br> 
on the selection of an effective data structure. An algorithm can become more effective and quick with the right data format. For <br>
instance, a hash table is a popular data structure for quick data retrieval and searching.
</font>
<h1>What are Data Structures and types?</h1>
<font size="4px" face="cursive">
Data structures are specific methods for setting up and keeping data in a computer so that it may be accessed, changed, and searched<br>
quickly. There are many different kinds of data structures, and each has benefits and drawbacks that vary depending on the objectives<br>
of the application.</font>
<h2>1. Arrays</h2>
<font size="4px" face="cursive">
Arrays are a type of data structure that keep a group of identically categorised elements in close proximity to one another in memory. <br> 
Despite having a fixed size, they can be ineffective for dynamic data or big datasets since they require constant-time access to <br>
individual items via an index.  
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Index-based constant-time access to individual elements <br>
2. For tiny, fixed-size data sets, effective <br>
3. Simple to use and understand  
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Uniform size <br>
2.Ineffective for large or dynamic data set
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
a list of contact details <br>
a list of test results 
</font>
<h2>2. Linked Lists</h2>
<font size="4px" face="cursive">
Linked lists are a type of data structure that are made up of a series of nodes, each of which contains an element and a reference <br>
to the node after it in the list. They are distinguished by their speedy insert and delete of elements, but because of their <br>
non-contiguous memory allocation, their traversal may be slower than arrays.
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Effective element addition and deletion <br>
2. Varying size <br>
3. Memory-efficient
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Traversing more slowly than arrays <br>
2. Less effective for gaining access to specific elements <br>
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
a musical playlis <br>
books listed
</font>
<h2>3. Stacks and Queues</h2>
<font size="4px" face="cursive">
Data structures used for handling a group of components include stacks and queues. The LIFO (last-in, first-out) ordering <br>
of stacks distinguishes them from queues, which are distinguished by the FIFO (first-in, first-out) ordering.  
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Easy to implement and comprehend <br>
2. Effective element addition and deletion   
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Limited access to certain features <br>
2. Ineffective for sorting and searching  
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
In text editors, stacks can be utilized for the undo/redo capability. <br>
In a printer queue, queues can be used to manage print jobs.   
</font>
<h2>4. Trees</h2>
<font size="4px" face="cursive">
Trees are a type of hierarchical data structure that is made up of nodes and edges. There is one node known as the root <br>
that has no parents, and each node can have one or more children. The ability to efficiently explore and arrange data in a <br>
hierarchical fashion is a characteristic of trees. 
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Effective data sorting and searching<br>
2. Useful for displaying hierarchical relationships  
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Unable to handle dynamic data <br>
2. Difficult to implement and comprehend Examples  
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
The computer’s file system <br>
A company’s organizational chart 
</font>
<h2>5. Graphs:</h2>
<font size="4px" face="cursive">
A graph is a data structure made up of nodes (vertices) and the connections between them (edges). They are useful for <br>
modelling networks, social media connections, and a variety of other tasks because they can depict intricate interconnections <br>
between data.
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Modular and effective for simulating intricate interactions<br>
2. Can depict a variety of real-world scenarios.
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Difficult to implement and comprehend <br>
2. Large data sets’ search and sorting efficiency is poor
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
Using social media<br>
Road systems
</font>
<h1>What are Algorithms and types?</h1>
<font size="4px" face="cursive">
Algorithms are a collection of instructions or rules that must be followed in order to complete a task or solve an issue. There <br>
are many different kinds of algorithms, and each has benefits and drawbacks that vary depending on the particular issue being solved.  
</font>
<h2>1. Sorting Algorithms</h2>
<font size="4px" face="cursive">
Sorting algorithms are employed to categorize and organize the elements of a list or an array. Several of the most popular sorting <br>
formulas include: <br>
1. Bubble Sort <br>
2. Selection Sort <br>
3. Insertion Sort <br>
4. Quick Sort <br>
5. Merge Sort  
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Able to sort huge datasets effectively <br>
2. Large-scale data analysis and search useful; can be tailored to meet certain requirements
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. For small datasets, some sorting techniques can be ineffective. <br>
2. Certain algorithms need more processing power or memory
</font>
<h2>2. Searching Algorithms</h2>
<font size="4px" face="cursive">
Searching Algorithms:  are employed to locate a particular element in a list or an array. The following are some of the most popular <br>
search algorithms: <br>
a linear search iterates through the list element by element. <br>
Binary Search divides the list into two halves, compares the middle element with the target element, and then repeatedly searches the <br> 
relevant half of the list.
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. An effective search of big datasets<br>
2. Useful for locating specific list items <br>
3. Can be modified to meet particular demands
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Certain search algorithms demand that the list be sorted first. <br>
2. If the required element is not present in the list, some algorithms may fail to find it.
</font>
<h2>3. Recursive Algorithms</h2>
<font size="4px" face="cursive">
Recursive algorithms are those that call themselves in order to solve a problem. They can be applied to a wide range of issues, <br> 
including search and sorting algorithms.
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
Using the Fibonacci sequence to traverse a binary tree
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Able to solve challenging issues<br>
2. Can some cases be more effective than non-recursive algorithms <br>
3. For some issues, it might be simpler to comprehend and put into practice.
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Potentially memory-intensive compared to non-recursive algorithms <br>
2. May some circumstances be less effective than non-recursive algorithms
</font>
<h2>4. Greedy Algorithms</h2>
<font size="4px" face="cursive">
Greedy Algorithms: In order to achieve a globally optimal solution, greedy algorithms choose the locally optimal option at each step.<br> 
They are frequently employed for optimization issues.
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
The issue with coin exchange <br>
Dijkstra’s shortest path algorithm
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Able to solve problems fast<br>
2. Frequently offer accurate approximations to ideal answers<br>
3. Can be applied to a variety of issues
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. May not always come up with the world’s best answer <br>
2. It can be challenging to decide when a greedy algorithm is necessary.
</font>
<h2>5. Dynamic Programming Algorithms</h2>
<font size="4px" face="cursive">
Algorithms for Dynamic Programming: Dynamic programming algorithms divide a problem into smaller subproblems and solve each <br>
subproblem just once. They can be more effective than brute force techniques and are frequently employed for optimization challenges.   
</font>
<h3>Examples:</h3>
<font size="4px" face="cursive">
The issue with knapsacks<br>
Longest common sequence issue 
</font>
<h3>Pros:</h3>
<font size="4px" face="cursive">
1. Can effectively tackle complicated problems<br>
2. Can be applied to a variety of issues<br>
3. Frequently offer ideal answers
</font>
<h3>Cons:</h3>
<font size="4px" face="cursive">
1. Can be challenging to use and comprehend <br>
</font>
</body>
</html>